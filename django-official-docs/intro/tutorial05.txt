=====================================
编写你的第一个 Django 应用, part 5
=====================================

本教程紧接 :doc:`Tutorial 4 </intro/tutorial04>` 之后。
我们已经构建了一个 Web-poll （译注：基于 web 的投票软件）应用，现在我们将要为它创建一些自动化的测试。

自动化测试简介
=============================

自动化测试是什么？
-------------------------

测试为了检查代码行为是否正常的一种简便的手段。

测试可以针对不同层次的目标进行。有些测试时针对一些细节(*一个模型内的方法是否返回了正确的值?*) 而有的测试是针对更上层的软件行为 (*用户在网页上的输入是否得到了预期的结果?*)。这与先前在 :doc:`Tutorial 2 </intro/tutorial02>`中做的测试没有区别， 使用:djadmin:`shell` 来运行一个方法，或者运行应用程序并输入数据检查它是的行为是否符合预期.

对自动化测试来说，区别在于测试工作是有一套系统来完成。你只要创建一些测试，然后修改你开发的代码，你就能价差你的代码是否依然如你期望的那样运行良好，而不用花费时间在手动测试上边。

为什么你需要创建测试
----------------------------

那么为什么需要使用测试，为什么是现在需要？

也许你觉得只要学习了 Python 或 Django 就已经完全足够了，在学习其他的东西就有点画蛇添足显得毫无必要。毕竟，目前看来我们的投票程序效果很好；花力气掌握自动化测试并不会让它去的更好的效果。如果构建这个投票程序是你用 Django 做的最后一件事情，那么，确实你不需要掌握如何创建自动化测试。但是，如果你还需要做更多的应用，这就是开始学习自动化测试最佳的时机。

自动化测试能够节约你的时间
~~~~~~~~~~~~~~~~~~~~~~~~

某种程度上来说, '检查软件是否在正常运行' 就算一个不错的测试了。对更复杂一些的情况来说，它可能需要几十个组件相互之间进行协作。

对其中一个组件进行修改就可能引发软件产生一些异常的情况。还是检查 '能够正常运行' 可能意味着输入大量的测试数据然后运行你的代码用以检查修改是否导致哪一部分发生了损坏，这是对时间极大的浪费。

自动化测试切实能够在极短的时间内帮你完成以上的工作。如果有哪里出了问题，它也能保你定位到引发问题的代码是在哪里。

停下编写代码来做其他的事情似乎让然觉得厌烦，尤其是投入到单调乏味的测试工作中，特别是在你的代码明明运行良好的时候。

然而，编写测试依然比化肥数小时通过手工测试的方法寻找一个新一如的bug要让人感到轻松。

测试不仅仅起到定位问题的作用，测试能够证实它们
​~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

把测试工作当做开发过程中令人厌烦的事情是错误的。

如果没有测试，开发出来的软件是否达到了预期的效果就是无法证实的。即使这些代码都是你亲自编写的，你还是会为了确认软件的真实行为而手动在各项功能中试来试去。

测试能够改变这种情况，它从内部检视你的代码，一旦有什么地方不对劲，它就会明确的指出出问题的地方。（即使在你还没有发现到你的代码已经有bug了的时候）

测试让你的代码更优雅
​~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

或许在你编写的软件中有一些亮点，但是你发现因为它们缺乏对应的测试其他的开发者要复用他们很困难；没有测试，他们不能完全信任这些代码。Jacob Kaplan-Moss，作为 Django 的初始开发者之一，曾今说过“没有测试的代码就是未经设计的。“

驱使你开始为代码编写测试的另一个原因在于，其他的开发者在复用你的代码之前，都强烈希望看到对应的测试。

测试帮助团队更好的协作
​~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

前边提到的各个视角都是从耽搁开发者维护一个软件的角度出发。更复杂一些的软件则需要一个团队来进行维护。测试可以确保其他成员不会一不留神破坏了你的代码(同样也防止你在不知情的情况下破坏了其他人的代码)。如果你想要成为一个 Django 开发者，你必须善于编写测试！

基本的测试策略
========================

这里有一些编写测试的方法。

一些程序员遵循叫做"`测试驱动开发”的开发方式`_"；他们在编码之前先编写测试。这可能和我们的直觉相反，但是确实人们是按照类似的方法做：他们描述一个问题，然后编写一些代码来解决它。测试驱动开发在的方式在 Python 的测试用例中分方便使用。

进一步来说，一个测试技术的初学者会先写一些代码，然后决定哪一部分代码需要测试。也许你觉得要是之前就开始用测试的开发方式就好了，但是现在开始也不算晚。

有时候要找到从什么地方开始写测试是有一些困难的。如果你写过很多的 Python 代码，找到需要测试的地方不会太难。这样，当你要修改代码的时候你就会发现之前写的测试时非常有价值的，不管这些改变是增加一个新功能还是修复一个 bug。

所以让我现在就开始吧。

.. _test-driven development: https://en.wikipedia.org/wiki/Test-driven_development

编写我们的第一个测试
======================

我们来识别一个 bug
-----------------

很幸运，在我们的``投票``应用中有一个小 bug 正等待我们修复：``Question.was_published_recently()`` 方法的返回值为 ``True`` 当 ``Question`` 在最后一天发布出来的时候（这个逻辑是正确的）但是当 ``Question``的 ``pub_date`` 字段是一个未来的日期它也会返回``True`` (这时就不对了).

为了检查这个 bug 是否真的存在，可是使用 Admin 创建一个问题，并将问题的发布日期设置为一个未来的日期，并且通过 :djadmin:`shell`::来检查这个方法

    >>> import datetime
    >>> from django.utils import timezone
    >>> from polls.models import Question
    >>> # 创建一个 Question 实例并将 pub_date 设为30天后的日期
    >>> future_question = Question(pub_date=timezone.now() + datetime.timedelta(days=30))
    >>> # 它在最近被发布了么?
    >>> future_question.was_published_recently()
    True

既然我们将它设置在30天后而不是`近期`，那么这个结果肯定是错误的。

创建一个测试来发现 bug
-------------------------------

我们刚通过 :djadmin:`shell` 所做的，也是我们希望通过自动化测试完成的事情，现在就让我们把它转化为自动化的方式吧。

习惯上我们会吧一个软件的测试放在这个工程的``tests.py`` 文件里; 测试框架将会在任何以``test``开头的文件中加载我们写的测试。

在``polls``项目的``tests.py``文件中输入一下的代码：

.. snippet::
    :filename: polls/tests.py

    import datetime

    from django.utils import timezone
    from django.test import TestCase

    from .models import Question


    class QuestionModelTests(TestCase):

        def test_was_published_recently_with_future_question(self):
            """
            was_published_recently() 方法当问题的 pub_date (发布日期)字段是未来的日期是返回 False。
            """
            time = timezone.now() + datetime.timedelta(days=30)
            future_question = Question(pub_date=time)
            self.assertIs(future_question.was_published_recently(), False)

这里，我们所做的事情是，创建了一个 :class:`django.test.TestCase` 类的子类，并在里边写了一个方法。这个方法创建一个``Question``实例并给它设置一个未来的发布日期。然后，我们检查``was_published_recently()`` 方法的输出- 看输出*是否*是False.

运行测试
-------------

通过命令行，我们可与运行我们编写的测试::

    $ python manage.py test polls

然后你应该看到类似下方的文字显示::

    Creating test database for alias 'default'...
    System check identified no issues (0 silenced).
    F
    ======================================================================
    FAIL: test_was_published_recently_with_future_question (polls.tests.QuestionModelTests)
    ----------------------------------------------------------------------
    Traceback (most recent call last):
      File "/path/to/mysite/polls/tests.py", line 16, in test_was_published_recently_with_future_question
        self.assertIs(future_question.was_published_recently(), False)
    AssertionError: True is not False

    ----------------------------------------------------------------------
    Ran 1 test in 0.001s

    FAILED (failures=1)
    Destroying test database for alias 'default'...

这个命令所做的事情是:

* ``python manage.py test polls`` 命令寻找 ``polls`` 应用里边我们编写的测试

* 它找到的是 :class:`django.test.TestCase` 类的子类

* 为了测试它创建了一个特殊的数据库

* 它寻找需要运行的测试方法 - 测试方法都以 ``test`` 作为前缀

* 在 ``test_was_published_recently_with_future_question`` 方法中创建了一个 ``Question`` 对象的实例，并给他的 ``pub_date`` 字段设置为30天以后的日期

* ... 然后使用 ``assertIs()`` 方法，它可会发现 ``was_published_recently()`` 方法的返回值是 ``True``， 尽管我们希望这个返回值是 ``False``

这个测试告诉我们哪一个测试没有通过，甚至是因为哪一行代码导致的失败。

修复 bug
--------------

我们已经知道了问题是: ``Question.was_published_recently()`` 方法应当返回 ``False`` 当``pub_date`` 字段是一个未来的日期时。 修改
``models.py``文件中的方法, 让它只返回 ``True`` 即使日期是一个过去的日期:

.. snippet::
    :filename: polls/models.py

    def was_published_recently(self):
        now = timezone.now()
        return now - datetime.timedelta(days=1) <= self.pub_date <= now

然后再次运行测试::

    Creating test database for alias 'default'...
    System check identified no issues (0 silenced).
    .
    ----------------------------------------------------------------------
    Ran 1 test in 0.001s

    OK
    Destroying test database for alias 'default'...

在我们发现一个 bug 之后，我们写一个测试来确认它，然后修改我们的代码让代码通过测试。

将来我们的程序还会发生各种各样的 bug ，但是我们可以肯定这个 bug 不会再被引入，因为它一旦发生就会立即被我们之前写的测试发现并提醒我们。有了测试我们就一劳永逸的解决了这个问题。

更复杂一些的测试
------------------------

既然我们已经做了这些测试工作，我们可以进一步的加强 ``was_published_recently()``
方法; 实际上, 当我们修复一个 bug 同时又引入新的 bug 这是很令人沮丧的。

给同一个类再增加两个测试方法，主要是针对更复杂一些的情况:

.. snippet::
    :filename: polls/tests.py

    def test_was_published_recently_with_old_question(self):
        """
        was_published_recently() 返回 False 当 questions 的 pub_date
        是一天之前的日期。
        """
        time = timezone.now() - datetime.timedelta(days=1, seconds=1)
        old_question = Question(pub_date=time)
        self.assertIs(old_question.was_published_recently(), False)

    def test_was_published_recently_with_recent_question(self):
        """
        was_published_recently() 返回 True 当 questions 的 pub_date
        是最近一天的日期。
        """
        time = timezone.now() - datetime.timedelta(hours=23, minutes=59, seconds=59)
        recent_question = Question(pub_date=time)
        self.assertIs(recent_question.was_published_recently(), True)

这样我们就有了三个测试用于确认 ``Question.was_published_recently()``
方法的返回值在发布日期是过去、现在、将来三种情况下都是正确的。

再次提示, ``polls`` 是一个简单的应用，但是将来它可能会变的复杂，不管后续它会增加多少代码，对于那些编写了响应测试的方法我们可以保证他们依然是按照我们的预期在工作的。

测试视图
===========

我们编写的投票应用非常的机械：他会发布任何的问题，哪怕这个问题设置的发布日期是将来的日子。我们应当改进它。把 ``pub_date`` 设置为一个将来的日期，应当意味着这个问题虽然立即被发布，但是在将来他再能被看到。

一个针对视图的测试
-----------------

当我们修复上边提到的 bug 时，我们先编写测试然后再修复 bug。实际上这是一个测试驱动开的小例子，但是它是实际工作中的工作顺序还是有些区别的。

在我们的第一个测试中，我们主要关注代码的内部逻辑。现在，我们想要关注的是它通过浏览器给用户呈现的内容是否是我们襄阳展现的。

在我们动手修复任何东西之前，让我们先来看看我们有什么工具可用。

The Django test client
----------------------

Django provides a test :class:`~django.test.Client` to simulate a user
interacting with the code at the view level.  We can use it in ``tests.py``
or even in the :djadmin:`shell`.

We will start again with the :djadmin:`shell`, where we need to do a couple of
things that won't be necessary in ``tests.py``. The first is to set up the test
environment in the :djadmin:`shell`::

    >>> from django.test.utils import setup_test_environment
    >>> setup_test_environment()

:meth:`~django.test.utils.setup_test_environment` installs a template renderer
which will allow us to examine some additional attributes on responses such as
``response.context`` that otherwise wouldn't be available. Note that this
method *does not* setup a test database, so the following will be run against
the existing database and the output may differ slightly depending on what
questions you already created. You might get unexpected results if your
``TIME_ZONE`` in ``settings.py`` isn't correct. If you don't remember setting
it earlier, check it before continuing.

Next we need to import the test client class (later in ``tests.py`` we will use
the :class:`django.test.TestCase` class, which comes with its own client, so
this won't be required)::

    >>> from django.test import Client
    >>> # create an instance of the client for our use
    >>> client = Client()

With that ready, we can ask the client to do some work for us::

    >>> # get a response from '/'
    >>> response = client.get('/')
    Not Found: /
    >>> # we should expect a 404 from that address; if you instead see an
    >>> # "Invalid HTTP_HOST header" error and a 400 response, you probably
    >>> # omitted the setup_test_environment() call described earlier.
    >>> response.status_code
    404
    >>> # on the other hand we should expect to find something at '/polls/'
    >>> # we'll use 'reverse()' rather than a hardcoded URL
    >>> from django.urls import reverse
    >>> response = client.get(reverse('polls:index'))
    >>> response.status_code
    200
    >>> response.content
    b'\n    <ul>\n    \n        <li><a href="/polls/1/">What&#39;s up?</a></li>\n    \n    </ul>\n\n'
    >>> response.context['latest_question_list']
    <QuerySet [<Question: What's up?>]>

Improving our view
------------------

The list of polls shows polls that aren't published yet (i.e. those that have a
``pub_date`` in the future). Let's fix that.

In :doc:`Tutorial 4 </intro/tutorial04>` we introduced a class-based view,
based on :class:`~django.views.generic.list.ListView`:

.. snippet::
    :filename: polls/views.py

    class IndexView(generic.ListView):
        template_name = 'polls/index.html'
        context_object_name = 'latest_question_list'

        def get_queryset(self):
            """Return the last five published questions."""
            return Question.objects.order_by('-pub_date')[:5]

We need to amend the ``get_queryset()`` method and change it so that it also
checks the date by comparing it with ``timezone.now()``. First we need to add
an import:

.. snippet::
    :filename: polls/views.py

    from django.utils import timezone

and then we must amend the ``get_queryset`` method like so:

.. snippet::
    :filename: polls/views.py

    def get_queryset(self):
        """
        Return the last five published questions (not including those set to be
        published in the future).
        """
        return Question.objects.filter(
            pub_date__lte=timezone.now()
        ).order_by('-pub_date')[:5]

``Question.objects.filter(pub_date__lte=timezone.now())`` returns a queryset
containing ``Question``\s whose ``pub_date`` is less than or equal to - that
is, earlier than or equal to - ``timezone.now``.

Testing our new view
--------------------

Now you can satisfy yourself that this behaves as expected by firing up the
runserver, loading the site in your browser, creating ``Questions`` with dates
in the past and future, and checking that only those that have been published
are listed.  You don't want to have to do that *every single time you make any
change that might affect this* - so let's also create a test, based on our
:djadmin:`shell` session above.

Add the following to ``polls/tests.py``:

.. snippet::
    :filename: polls/tests.py

    from django.urls import reverse

and we'll create a shortcut function to create questions as well as a new test
class:

.. snippet::
    :filename: polls/tests.py

    def create_question(question_text, days):
        """
        Create a question with the given `question_text` and published the
        given number of `days` offset to now (negative for questions published
        in the past, positive for questions that have yet to be published).
        """
        time = timezone.now() + datetime.timedelta(days=days)
        return Question.objects.create(question_text=question_text, pub_date=time)


    class QuestionIndexViewTests(TestCase):
        def test_no_questions(self):
            """
            If no questions exist, an appropriate message is displayed.
            """
            response = self.client.get(reverse('polls:index'))
            self.assertEqual(response.status_code, 200)
            self.assertContains(response, "No polls are available.")
            self.assertQuerysetEqual(response.context['latest_question_list'], [])

        def test_past_question(self):
            """
            Questions with a pub_date in the past are displayed on the
            index page.
            """
            create_question(question_text="Past question.", days=-30)
            response = self.client.get(reverse('polls:index'))
            self.assertQuerysetEqual(
                response.context['latest_question_list'],
                ['<Question: Past question.>']
            )

        def test_future_question(self):
            """
            Questions with a pub_date in the future aren't displayed on
            the index page.
            """
            create_question(question_text="Future question.", days=30)
            response = self.client.get(reverse('polls:index'))
            self.assertContains(response, "No polls are available.")
            self.assertQuerysetEqual(response.context['latest_question_list'], [])

        def test_future_question_and_past_question(self):
            """
            Even if both past and future questions exist, only past questions
            are displayed.
            """
            create_question(question_text="Past question.", days=-30)
            create_question(question_text="Future question.", days=30)
            response = self.client.get(reverse('polls:index'))
            self.assertQuerysetEqual(
                response.context['latest_question_list'],
                ['<Question: Past question.>']
            )

        def test_two_past_questions(self):
            """
            The questions index page may display multiple questions.
            """
            create_question(question_text="Past question 1.", days=-30)
            create_question(question_text="Past question 2.", days=-5)
            response = self.client.get(reverse('polls:index'))
            self.assertQuerysetEqual(
                response.context['latest_question_list'],
                ['<Question: Past question 2.>', '<Question: Past question 1.>']
            )


Let's look at some of these more closely.

First is a question shortcut function, ``create_question``, to take some
repetition out of the process of creating questions.

``test_no_questions`` doesn't create any questions, but checks the message:
"No polls are available." and verifies the ``latest_question_list`` is empty.
Note that the :class:`django.test.TestCase` class provides some additional
assertion methods. In these examples, we use
:meth:`~django.test.SimpleTestCase.assertContains()` and
:meth:`~django.test.TransactionTestCase.assertQuerysetEqual()`.

In ``test_past_question``, we create a question and verify that it appears in
the list.

In ``test_future_question``, we create a question with a ``pub_date`` in the
future. The database is reset for each test method, so the first question is no
longer there, and so again the index shouldn't have any questions in it.

And so on. In effect, we are using the tests to tell a story of admin input
and user experience on the site, and checking that at every state and for every
new change in the state of the system, the expected results are published.

Testing the ``DetailView``
--------------------------

What we have works well; however, even though future questions don't appear in
the *index*, users can still reach them if they know or guess the right URL. So
we need to add a similar  constraint to ``DetailView``:

.. snippet::
    :filename: polls/views.py

    class DetailView(generic.DetailView):
        ...
        def get_queryset(self):
            """
            Excludes any questions that aren't published yet.
            """
            return Question.objects.filter(pub_date__lte=timezone.now())

And of course, we will add some tests, to check that a ``Question`` whose
``pub_date`` is in the past can be displayed, and that one with a ``pub_date``
in the future is not:

.. snippet::
    :filename: polls/tests.py

    class QuestionDetailViewTests(TestCase):
        def test_future_question(self):
            """
            The detail view of a question with a pub_date in the future
            returns a 404 not found.
            """
            future_question = create_question(question_text='Future question.', days=5)
            url = reverse('polls:detail', args=(future_question.id,))
            response = self.client.get(url)
            self.assertEqual(response.status_code, 404)

        def test_past_question(self):
            """
            The detail view of a question with a pub_date in the past
            displays the question's text.
            """
            past_question = create_question(question_text='Past Question.', days=-5)
            url = reverse('polls:detail', args=(past_question.id,))
            response = self.client.get(url)
            self.assertContains(response, past_question.question_text)

Ideas for more tests
--------------------

We ought to add a similar ``get_queryset`` method to ``ResultsView`` and
create a new test class for that view. It'll be very similar to what we have
just created; in fact there will be a lot of repetition.

We could also improve our application in other ways, adding tests along the
way. For example, it's silly that ``Questions`` can be published on the site
that have no ``Choices``. So, our views could check for this, and exclude such
``Questions``. Our tests would create a ``Question`` without ``Choices`` and
then test that it's not published, as well as create a similar ``Question``
*with* ``Choices``, and test that it *is* published.

Perhaps logged-in admin users should be allowed to see unpublished
``Questions``, but not ordinary visitors. Again: whatever needs to be added to
the software to accomplish this should be accompanied by a test, whether you
write the test first and then make the code pass the test, or work out the
logic in your code first and then write a test to prove it.

At a certain point you are bound to look at your tests and wonder whether your
code is suffering from test bloat, which brings us to:

When testing, more is better
============================

It might seem that our tests are growing out of control. At this rate there will
soon be more code in our tests than in our application, and the repetition
is unaesthetic, compared to the elegant conciseness of the rest of our code.

**It doesn't matter**. Let them grow. For the most part, you can write a test
once and then forget about it. It will continue performing its useful function
as you continue to develop your program.

Sometimes tests will need to be updated. Suppose that we amend our views so that
only ``Questions`` with ``Choices`` are published. In that case, many of our
existing tests will fail - *telling us exactly which tests need to be amended to
bring them up to date*, so to that extent tests help look after themselves.

At worst, as you continue developing, you might find that you have some tests
that are now redundant. Even that's not a problem; in testing redundancy is
a *good* thing.

As long as your tests are sensibly arranged, they won't become unmanageable.
Good rules-of-thumb include having:

* a separate ``TestClass`` for each model or view
* a separate test method for each set of conditions you want to test
* test method names that describe their function

Further testing
===============

This tutorial only introduces some of the basics of testing. There's a great
deal more you can do, and a number of very useful tools at your disposal to
achieve some very clever things.

For example, while our tests here have covered some of the internal logic of a
model and the way our views publish information, you can use an "in-browser"
framework such as Selenium_ to test the way your HTML actually renders in a
browser. These tools allow you to check not just the behavior of your Django
code, but also, for example, of your JavaScript. It's quite something to see
the tests launch a browser, and start interacting with your site, as if a human
being were driving it! Django includes :class:`~django.test.LiveServerTestCase`
to facilitate integration with tools like Selenium.

If you have a complex application, you may want to run tests automatically
with every commit for the purposes of `continuous integration`_, so that
quality control is itself - at least partially - automated.

A good way to spot untested parts of your application is to check code
coverage. This also helps identify fragile or even dead code. If you can't test
a piece of code, it usually means that code should be refactored or removed.
Coverage will help to identify dead code. See
:ref:`topics-testing-code-coverage` for details.

:doc:`Testing in Django </topics/testing/index>` has comprehensive
information about testing.

.. _Selenium: http://seleniumhq.org/
.. _continuous integration: https://en.wikipedia.org/wiki/Continuous_integration

What's next?
============

For full details on testing, see :doc:`Testing in Django
</topics/testing/index>`.

When you're comfortable with testing Django views, read
:doc:`part 6 of this tutorial</intro/tutorial06>` to learn about
static files management.

~~~~~~~~~~~~~~~~~~~~~~~~